#######################################################################################
#######                             ATENTION                                    #######
#######  This demo is meant to show how QI authentication works, the endpoints  #######
#######  used on this example may change in the future!                         #######
########################################################################################


import json
from datetime import datetime, timedelta
from hashlib import md5

from jose import jwt
from requests import post, get, patch, delete

# Private key generated by client, SECRET! Must not be given to anyone
CLIENT_PRIVATE_KEY = """-----BEGIN EC PRIVATE KEY-----
MIHcAgEBBEIAyRa+hgmiOpzUN+/0vAMLZxeK7MWtJnBU+eFpp+ydOgRUbQRfg/Mv
tLiKPNOfG9h1Nf45nBG4TQvzSEgLn5zcpY2gBwYFK4EEACOhgYkDgYYABAHOrn3p
sZdRWjR5or0J3eBq+oaizCKKGvZFoNSBmV5WoXcxZJfWE8KLNjqo2+DzxIpEd4ua
PaJJHD6yY577MLWYXQCAJJ3a3/Pey7Blcu6M2rxKnCst5BQ5rV4OEz0HZv4KbjOI
lLjqJ0I/IUa9RmbS7oaTTm55ExLrGc20hJA1L755Dw==
-----END EC PRIVATE KEY-----"""
# Client api-key, provided by QI to client
API_KEY = "16c8a1ec-8d75-47a1-b138-46746713b8d8"

# QI public key, generate by QI and provided to client
QI_PUBLIC_KEY = """-----BEGIN PUBLIC KEY-----
MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQBDb+aZEZL+/kJPVl7UkenxDxAZ5pP
spInjNRhKm2OWqRjaxADn3ljkUf0uodxNx6JhS4hJNexHzTYZ5DPoWJpoHwAKmrl
VGohj/xxedcmwNfxhjavvNsJ+WK2bmBSl7KDuZKY/6+kxCHiVp3gRN42rEXpnjCG
wW6gCqJdukkBqAMfbyg=
-----END PUBLIC KEY-----"""

QI_AUTH_ADDRESS = "https://api-auth.sandbox.qitech.app"
RESPONSE_MINUTES_TOLERANCE = 5


def get_test(endpoint):

    # Request parameters
    url = f"{QI_AUTH_ADDRESS}{endpoint}"
    method = "GET"

    # Signed request
    header, body = qi_sign_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        client_private_key=CLIENT_PRIVATE_KEY,
        body=None,
        content_type="",
        additional_headers=None,
    )
    print(header)
    # Request execution
    resp = get(url=url, headers=header, timeout=100)

    # Response translated
    response_body = json.loads(resp.text)
    response_header = resp.headers
    response = qi_translate_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        qi_public_key=QI_PUBLIC_KEY,
        response_body=response_body,
        response_header=response_header,
    )

    return response, resp


def post_test(endpoint, payload):

    url = f"{QI_AUTH_ADDRESS}{endpoint}"
    # Request parameters

    body = payload
    method = "POST"
    content_type = "application/json"

    # Signed request
    header, body = qi_sign_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        client_private_key=CLIENT_PRIVATE_KEY,
        body=body,
        content_type=content_type,
    )

    # Request execution
    resp = post(url=url, headers=header, json=body, timeout=900)

    # Response translated
    response_body = json.loads(resp.text)
    response_header = resp.headers
    response = qi_translate_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        qi_public_key=QI_PUBLIC_KEY,
        response_body=response_body,
        response_header=response_header,
    )
    print(response)
    return response, resp


def patch_test(endpoint, payload):

    url = f"{QI_AUTH_ADDRESS}{endpoint}"
    # Request parameters

    body = payload
    content_type = "application/json"
    method = "PATCH"

    # Signed request
    header, body = qi_sign_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        client_private_key=CLIENT_PRIVATE_KEY,
        body=body,
        content_type=content_type,
    )

    # Request execution
    resp = patch(url=url, headers=header, json=body, timeout=100)

    # Response translated
    response_body = json.loads(resp.text)
    response_header = resp.headers
    response = qi_translate_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        qi_public_key=QI_PUBLIC_KEY,
        response_body=response_body,
        response_header=response_header,
    )
    print(response)
    return response, resp


def delete_test(endpoint):

    # Request parameters
    url = f"{QI_AUTH_ADDRESS}{endpoint}"
    method = "DELETE"

    # Signed request
    header, body = qi_sign_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        client_private_key=CLIENT_PRIVATE_KEY,
        body=None,
        content_type="",
        additional_headers=None,
    )
    print(header)
    # Request execution
    resp = delete(url=url, headers=header, timeout=100)

    # Response translated
    response_body = json.loads(resp.text)
    response_header = resp.headers
    response = qi_translate_message(
        endpoint=endpoint,
        method=method,
        api_key=API_KEY,
        qi_public_key=QI_PUBLIC_KEY,
        response_body=response_body,
        response_header=response_header,
    )

    return response, resp


def qi_sign_message(
    endpoint,
    method,
    api_key,
    client_private_key,
    body=None,
    content_type="",
    additional_headers=None,
):

    md5_body = ""
    request_body = None
    if body:
        encoded_body_token = jwt.encode(
            claims=body, key=client_private_key, algorithm="ES512"
        )
        request_body = {"encoded_body": encoded_body_token}
        # Create body hash
        md5_encode = md5()
        md5_encode.update(encoded_body_token.encode())
        md5_body = md5_encode.hexdigest()

    date = datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S GMT")

    string_to_sign = (
        method + "\n" + md5_body + "\n" + content_type + "\n" + date + "\n" + endpoint
    )

    headers = {"alg": "ES512", "typ": "JWT"}
    claims = {"sub": api_key, "signature": string_to_sign}

    encoded_header_token = jwt.encode(
        claims=claims, key=client_private_key, algorithm="ES512", headers=headers
    )
    authorization = "QIT" + " " + api_key + ":" + encoded_header_token
    request_header = {"AUTHORIZATION": authorization, "API-CLIENT-KEY": api_key}

    if additional_headers:
        request_header.update(additional_headers)

    return request_header, request_body


def qi_translate_message(
    endpoint,
    method,
    api_key,
    qi_public_key,
    response_body,
    response_header=None,
    request_minutes_tolerance=RESPONSE_MINUTES_TOLERANCE,
):

    body = jwt.decode(
        response_body.get("encoded_body", None), key=qi_public_key, algorithms=["ES512"]
    )

    authorization = response_header.get("AUTHORIZATION")
    header_api_key = response_header.get("API-CLIENT-KEY")

    if header_api_key != api_key:
        raise Exception(
            "The api_key gathered on message's header does not match the one provided "
            "to the function"
        )

    split_authorization = authorization.split(":")
    if len(split_authorization) != 2:
        raise Exception("Wrong format for the Authorization header")

    authorization_api_key = split_authorization[0].split(" ")[1]
    if authorization_api_key != api_key:
        raise Exception(
            "The api_key gathered on message's authorization header does not match the "
            "one provided to the function"
        )

    header_token = split_authorization[1]
    decoded_header_token = jwt.decode(
        token=header_token, key=qi_public_key, algorithms=["ES512"]
    )
    signature = decoded_header_token.get("signature", None)
    split_signature = signature.split("\n")
    signature_method = split_signature[0]
    signature_md5_body = split_signature[1]
    # signature_content_type = split_signature[2]  # Not validated
    signature_date = split_signature[3]
    signature_endpoint = split_signature[4]

    if signature_endpoint != endpoint:
        raise Exception(
            "The 'endpoint' parameter gathered on message's signature does not match the "
            "one provided to the function"
        )

    if signature_method != method:
        raise Exception(
            "The 'method' parameter gathered on message's signature does not match the "
            "one provided to the function"
        )

    md5_encode = md5()
    md5_encode.update(response_body.get("encoded_body", None).encode())
    md5_body = md5_encode.hexdigest()
    if signature_md5_body != md5_body:
        raise Exception(
            "The 'md5_body' parameter gathered on message's signature does not match "
            "the 'body' provided to the function"
        )

    utc_now = datetime.utcnow()
    time_delta = timedelta(minutes=request_minutes_tolerance)
    utc_signature_date = datetime.strptime(signature_date, "%a, %d %b %Y %H:%M:%S GMT")
    if utc_signature_date > utc_now or utc_signature_date < (utc_now - time_delta):
        raise Exception("Invalid signature timestamp")

    return body



